package dao.tron.tsol.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import dao.tron.tsol.model.TransferData;
import org.junit.jupiter.api.Test;
import org.tron.trident.utils.Numeric;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Parity test: Java Merkle logic must match the scripts (source of truth).
 *
 * This test loads sc/script/merkle/batch/merkle_data_deploy.json (generated by the Python script)
 * and verifies:
 * - each txHash (leaf) matches Java leafHash()
 * - the computed Merkle root matches
 * - per-index Merkle proofs match exactly
 *
 * NOTE: Script JSON contains both EVM (0x...) and TRON base58 addresses. We use TRON base58
 * for Java TransferData because the Java backend operates on base58 inputs, but the underlying
 * 20-byte address is identical, so the resulting hashes must match.
 */
public class ScriptMerkleParityTest {

    private static final String SCRIPT_JSON_PATH = "sc/script/merkle/batch/merkle_data_deploy.json";

    @Test
    void merkleMatchesScriptJson() throws Exception {
        ObjectMapper om = new ObjectMapper();
        JsonNode rootNode = om.readTree(new File(SCRIPT_JSON_PATH));

        String expectedRoot = rootNode.get("merkleRoot").asText();
        long batchSalt = rootNode.hasNonNull("batchSalt") ? rootNode.get("batchSalt").asLong() : 0L;
        JsonNode txs = rootNode.get("transactions");

        MerkleTreeService merkle = new MerkleTreeService();

        List<byte[]> leaves = new ArrayList<>();
        List<String> expectedLeafHex = new ArrayList<>();
        List<List<String>> expectedProofs = new ArrayList<>();
        List<TransferData> transfers = new ArrayList<>();

        for (JsonNode tx : txs) {
            // addresses: use TRON base58 version from JSON to match Java inputs
            String fromBase58 = tx.get("tronAddresses").get("from").asText();
            String toBase58 = tx.get("tronAddresses").get("to").asText();

            JsonNode txDataStruct = tx.get("txDataStruct");
            String amount = txDataStruct.get(2).asText(); // string in JSON
            long nonce = txDataStruct.get(3).asLong();
            long timestamp = txDataStruct.get(4).asLong();
            int recipientCount = txDataStruct.get(5).asInt();
            long batchId = txDataStruct.get(6).asLong(); // NOT hashed, but carried in TransferData
            int txType = txDataStruct.get(7).asInt();

            TransferData td = new TransferData();
            td.setFrom(fromBase58);
            td.setTo(toBase58);
            td.setAmount(amount);
            td.setNonce(nonce);
            td.setTimestamp(timestamp);
            td.setRecipientCount(recipientCount);
            td.setBatchId(batchId);
            td.setTxType(txType);

            transfers.add(td);

            expectedLeafHex.add(tx.get("txHash").asText().toLowerCase());

            List<String> proof = new ArrayList<>();
            for (JsonNode p : tx.get("proof")) {
                proof.add(p.asText().toLowerCase());
            }
            expectedProofs.add(proof);
        }

        // 1) Leaf hashes must match script txHash
        for (int i = 0; i < transfers.size(); i++) {
            byte[] leaf = merkle.leafHash(transfers.get(i), batchSalt);
            leaves.add(leaf);
            String javaLeafHex = "0x" + Numeric.toHexStringNoPrefix(leaf);
            assertEquals(expectedLeafHex.get(i), javaLeafHex.toLowerCase(), "leaf/txHash mismatch at index " + i);
        }

        // 2) Root must match script merkleRoot
        String javaRoot = merkle.computeMerkleRoot(leaves);
        assertEquals(expectedRoot.toLowerCase(), javaRoot.toLowerCase(), "merkleRoot mismatch");

        // 3) Proofs must match exactly per index
        for (int i = 0; i < leaves.size(); i++) {
            List<String> javaProof = merkle.buildProof(leaves, i);
            List<String> expectedProof = expectedProofs.get(i);
            assertEquals(expectedProof, toLower(javaProof), "proof mismatch at index " + i);
        }
    }

    private static List<String> toLower(List<String> in) {
        List<String> out = new ArrayList<>(in.size());
        for (String s : in) out.add(s.toLowerCase());
        return out;
    }
}


